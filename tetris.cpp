// PSEUDO GAME v.0.1

#include <iostream> // cin, сout
#include <conio.h> // _getch()
#include <clocale> // Импортируем языковой модуль
#include <stdlib.h> // поддержка функции очистки экрана system("cls") и rand()
#include <time.h> // Здесь находится time() (нужна для генерации случ чисел) 


using namespace std;

const int strings = 22; // Количество строк в массиве (не более 98)
const int columns = 15; // Количество колонок в массиве (лучше НЕЧЕТНОЕ)
int x = 5; // две переменные для хранения координат игрока
int y = 2;
int square_x0 = 5;  // нулевая(начальная) координата квадрата по x
int square_y0 = 14;  // нулевая(начальная) координата квадрата по y
int square_x1 = 6; // вторая координата квадрата по x
int square_y1 = 15; // вторая координата квадрата по y
bool beyond; // условие для выхода из поля
char map[strings][columns]; // массив для хранения игровой карты
//int bottom_x[columns]; // массив для хранения дна по x
int bottom_y[strings][columns]; // массив для хранения дна по y
int control = 0; // переменная для выхода из игры
int warehouse_x; // две переменные для хранения координат склада
int warehouse_y;
char post_step = ' '; // символ который остается после того как игрок "ушел" с данной коордтнаты
char square_symbol = '0'; // символ квадрата (и всех фигур)
int slice_count = 0;
int summ = 0;


// ПРОТОТИПЫ (объявление функций)
int game_init(); // функция инициализирующая массив карты (map)
int bottom_init(); // функция инициализации дна
int on_limits(); // функция проверки выхода за пределы поля
void on_bottom(); // функция проверки на касание квадратом дна
int interaction(int& warehouse_count, int fuel, int full_fuel); // функция для взаимодействия с объектами на карте (склад)
void display_map(); // функция поэлементно выводящая массив на экран
int slice(); // функция среза дна
char square_filling(char symbol); // заполнение координат квадрата различными символами
int display_object(); // функция рисующая объекты на карте
int movement_if(int warehouse_count, int& fuel); // функция для действий игрока
int clock_down();
void game_over(int warehouse_count, int& fuel); // функция для вывода результатов игры на экран
void rand_gener(); // функция для генерации случайных координат
int tm_sec;

int main ()
{
  static int warehouse_count = 0; // сетчик  посещений склада (статическая переменная вызывается 1 раз и остается в памяти без изменений, хотя здесь это не обязательно т.к. main() вызывается только однажды)
  static int full_fuel = 10; // поллный бак топлива
  static int fuel = 10; // топливо
  setlocale(LC_CTYPE,"Russian"); // установка русского языка
  srand(time(NULL)); // текущее(NULL) системное время нужное для генерации псевдо случайных чисел

  rand_gener(); // функция генерации случайных координат (для склада)
  game_init(); // функция инициализирующия массив карты (map)
  bottom_init(); // функция инициализации дна
  while (control == 0) // цикл для игрового процесса повторяется пока игрок не нажмет F1
  {
    on_limits(); // функция пороверки на выход за границы
	on_bottom(); // функция проверки на касание квадрата дна
	slice(); // функция проверки на срез дна
	fuel = interaction(warehouse_count, fuel, full_fuel); // функция для взаимодействия с объектами на карте (склад, топливо) возвращает текущее топливо
	display_map(); // если все нормально (игрок в пределах карты и не взаимодействует с объектами) обновляем карту
	clock_down();
	//movement_if(warehouse_count, fuel); // функция действий игрока при нажатии клавиш (управление персонажем и игрой)
	if (control == 0) // при выходе из игры карту стирать не надо
		system("cls"); // очистка экрана
  }
  game_over(warehouse_count, fuel); // функция для вывода результатов игры на экран
  return 0; // выходим из main()
}

// ГЕНЕРАЦИЯ СЛУЧАЙНЫХ КООРДИНАТ
void rand_gener()
{
	int real_columns = ((columns-1)/2-3); // количество колонок на карте по которым реально может двигаться игрок (не стены)
	int real_strings = (strings-3); // количество строк на карте по которым реально может двигаться игрок (не стены)
	warehouse_x = rand() % real_columns + 2; // генерируем случайные числа от 2 до 13 включительно
	warehouse_y = rand() % real_strings + 2; // генерируем случайные числа от 2 до 10 включительно
	if (warehouse_x == x || warehouse_y == y ) // если координаты склада совпадут с координатами игрока - генерируем склад заново
	{
		rand_gener(); // генерируем координаты склада заново
	}
}
// ИНИЦИАЛИЗАЦИЯ МАССИВА КАРТЫ
int game_init() // функция инициализирующая массив карты (map)
{
	int digits[strings]; // массив для хранения цифр
	int letters[columns]; // массив для хранения букв

  	for (int i = 0; i < strings; i++) // внешний цикл отвечает за строки
	{
	  digits[i] = i; // Заполняем массив цифрами от 0 до i
	  for (int j = 0; j < columns; j++) // внутренний цикл отвечает за столбцы
	  {
		letters[j] = j; // Заполняем массив цифрами от 0 до j
		map[i][j] = ' ';	  // Заполняем весь массив 0-ями
		//map[0][j] = letters[j] + 63; // Переписываем верхнюю границу(1-ую половину) заполняя ее буквами
		//map[1][j] = '-';	  // Переписываем верхнюю границу
		map[strings-1][j] = '-'; // Переписываем нижнюю границу
	  }

	  for (int j = columns/2; j < columns; j++)		// Переписываем верхнюю границу(2-ую половину) заполняя ее буквами
	  {
	    //map[0][j] = letters[j-columns/2-1] + 63;	  // j-columns/2-1 нужно что бы начать с буквы А
	  }

	  map[i][0] = ' ';		  // Переписываем левую границу (первого поля)
	  map[i][1] = '|';		  // Переписываем левую границу (первого поля)
	  //map[i][columns/2-1] = '|';	  // Переписываем правую границу (первого поля)
	  //map[i][columns/2] = ' ';		  // Разделительная черта между полями
	  //map[i][columns/2+1] = digits[i] + 47;		  // Переписываем левую границу (второго поля) заполняя цифрами от 1-9
	  //map[i][columns/2+2] = '|';	  // Переписываем левую границу (второго поля)
	  map[i][columns-1] = '|';		  // Переписываем правую границу
	}
	map[0][0] = ' ';	// Переписываем углы поля
	map[0][1] = ' ';	// Переписываем углы поля
	map[1][0] = ' ';	// Переписываем углы поля
	map[1][1] = '#';	// Переписываем углы поля
	map[strings-1][0] = ' ';	// Переписываем углы поля
	map[strings-1][1] = '#';	// Переписываем углы поля
	map[0][columns-1] = ' ';	// Переписываем углы поля
	map[1][columns-1] = '#';	// Переписываем углы поля
	map[strings-1][columns-1] = '#';	// Переписываем углы поля
	//for (int i = columns/2-1; i <= columns/2+2; i++) 	// Переписываем углы поля посередине
	//{
	//	map[0][i] = ' '; // Переписываем углы поля посередине (сверху)
	//	map[1][i] = '#'; // Переписываем углы поля посередине (сверху)
	//	map[1][columns/2] = ' '; // Переписываем углы поля посередине (сверху)
	//	map[1][columns/2+1] = ' '; // Переписываем углы поля посередине (сверху)
	//	map[strings-1][i] = '#'; // Переписываем углы поля посередине (снизу)
	//	map[strings-1][columns/2] = ' '; // Переписываем углы поля посередине (снизу)
	//	map[strings-1][columns/2+1] = ' '; // Переписываем углы поля посередине (снизу)
	//}
	display_object(); // рисуем объекты на карте
	return 0; // выходим из функции инициализации массива карты
}
// ИНИЦИАЛИЗАЦИЯ МАССИВА ДНА
int bottom_init() // функция инициализирующая массив дна
{
	for (int i = 0; i < strings; i++){
		for (int j = 0; j < columns; j++){
			bottom_y[i][j] = 99; // заполняем массив 99ми - мусором
			bottom_y[strings-2][j] = strings-2; // массив для хранения дна по y. -2 учитывая графику "-"	
		}
	}
	return 0;
 }
// РИСУЕМ ОБЪЕКТЫ НА КАРТЕ
int display_object()
{
	static char symbol_gamer = 'T'; // символ игрока
	static char symbol_warehouse = 'W'; // символ игрока
	map[y][x] = symbol_gamer; // рисуем игрока
	map[warehouse_y][warehouse_x] = symbol_warehouse; // рисуем склад
	square_filling(square_symbol); // заполнение координат квадрата символом square_symbol - 0
	return 0;
}
// ПРОВЕРКА НА ВЫХОД КВАДРАТА ЗА ПРЕДЕЛЫ ПОЛЯ
int on_limits() // функция проверки выхода за пределы поля
{
  beyond = 0; // условие для выхода из поля
  while (beyond == 0) // выполняем цикл проверки на выход за пределы карты
  {
	  	if (square_y0 < 2) // Проверяем условие на выход квадрата за "ВЕРХНИЙ" предел карты
	{
			map[square_y0][square_x0] = '-';
			map[square_y0][square_x1] = '-';
			square_y0++;
			square_y1++;
			square_filling(square_symbol);
	}
		else if (square_y1 > strings-2) // Проверяем условие на выход игрока за "НИЖНИЙ" предел карты
	{
			map[square_y1][square_x0] = '-';
			map[square_y1][square_x1] = '-';
			square_y0--;
			square_y1--;
			square_filling(square_symbol);
	}
		else if (square_x0 < 2) // Проверяем условие на выход игрока за "ЛЕВЫЙ" предел первого поля
	{
			map[square_y0][square_x0] = '|';
			map[square_y1][square_x0] = '|';
			square_x0++;
			square_x1++;
			square_filling(square_symbol);
	}
		else if (square_x1 > columns-2) // Проверяем условие на выход игрока за "ПРАВЫЙ" предел поля
	{
			map[square_y0][square_x1] = '|';
			map[square_y1][square_x1] = '|';
			square_x0--;
			square_x1--;
			square_filling(square_symbol);
	}
		else if (square_y0-1 == bottom_y[square_y0-1][square_x1]) // Проверяем условие на боковой ПРАВЫЙ ТАРАН пирамиды по координате y1
	{
			map[square_y1][square_x1] = post_step; // если это выступ то край выступа заполняется пробелом
			if (square_y1-1 == bottom_y[square_y1-1][square_x1]){ // Дополнительно сравниваем координаты по у1 чтобы дорисовать 0 (если это прямая стена а не выступ)
				map[square_y1][square_x1] = square_symbol;
			}
			square_x0--;
			square_x1--;
			square_filling(square_symbol);
	}
		else if (square_y1-1 == bottom_y[square_y1-1][square_x1]) // Проверяем условие на боковой ПРАВЫЙ ТАРАН пирамиды по координате y0
	{
			map[square_y0][square_x1] = post_step; // если это выступ то край выступа заполняется пробелом
			if (square_y0-1 == bottom_y[square_y0-1][square_x1]){ // Дополнительно сравниваем координаты по у0 чтобы дорисовать 0 (если это прямая стена а не выступ)
				map[square_y0][square_x1] = square_symbol;
			}
			square_x0--;
			square_x1--;
			square_filling(square_symbol);
	}
		else if (square_y0-1 == bottom_y[square_y0-1][square_x0]) // Проверяем условие на боковой ЛЕВЫЙ ТАРАН пирамиды по координате y1
	{
			map[square_y1][square_x0] = post_step; // если это выступ то край выступа заполняется пробелом
			if (square_y1-1 == bottom_y[square_y1-1][square_x0]){ // Дополнительно сравниваем координаты по у1 чтобы дорисовать 0 (если это прямая стена а не выступ)
				map[square_y1][square_x0] = square_symbol;
			}
			square_x0++;
			square_x1++;
			square_filling(square_symbol);
	}
		else if (square_y1-1 == bottom_y[square_y1-1][square_x0]) // Проверяем условие на боковой ЛЕВЫЙ ТАРАН пирамиды по координате y0
	{
			map[square_y0][square_x0] = post_step; // если это выступ то край выступа заполняется пробелом
			if (square_y0-1 == bottom_y[square_y0-1][square_x0]){ // Дополнительно сравниваем координаты по у0 чтобы дорисовать 0 (если это прямая стена а не выступ)
				map[square_y0][square_x0] = square_symbol;
			}
			square_x0++;
			square_x1++;
			square_filling(square_symbol);
	}
		else // Если игрок не вышел за пределы карты выходим из функции
	{
			return beyond = 1; // выходим из цикла условий выхода за пределы карты
	}
  }
}
// ПРОВЕРКА НА КАСАНИЕ КВАДРАТОМ ДНА
void on_bottom() // функция проверки на касание квадратом дна
{
  //НУЖЕН ДВУМЕРНЫЙ МАССИВ!
	  	if (square_y1 >= bottom_y[square_y1][square_x0] ||
			square_y1 >= bottom_y[square_y1][square_x1]) // Проверяем условие на касание квадратом дна в соответствии с координатами x
	{
			square_filling(square_symbol); // при касании дна, на дне остается квадрат
			bottom_y[square_y0-1][square_x0] = square_y0-1; // дно заполняется т.е. у него меняются координаты у по координатам x
			bottom_y[square_y0-1][square_x1] = square_y0-1;
			bottom_y[square_y1-1][square_x0] = square_y1-1; // дно заполняется т.е. у него меняются координаты у по координатам x
			bottom_y[square_y1-1][square_x1] = square_y1-1;
			square_x0 = 5;				// при касании дна координаты квадрата возвращаются на вверх
			square_y0 = 14;				// при касании дна координаты квадрата возвращаются на вверх
			square_x1 = square_x0 + 1; // вторая координата квадрата по x возвращаются на вверх
			square_y1 = square_y0 + 1; // вторая координата квадрата по y возвращаются на вверх
			square_filling(square_symbol); // при касании дна квадрат возвращается на вверх и прорисовывается
			
	}
}
// ФУНКЦИЯ ДЛЯ ВЗАИМОДЕЙСТВИЯ С ОБЪЕКТАМИ НА КАРТЕ (СКЛАД, ТОПЛИВО)
int interaction(int& warehouse_count, int fuel, int full_fuel)
{
  bool warehouse_par = 0; // параметр необходимый для 'выхода' со склада
  char post_step = ' ';   // возвращаем назад символ который остается после того как игрок "ушел" со склада
		if (x == warehouse_x && y == warehouse_y && warehouse_par == 0) // Проверяем условие на попадание игрока на склад
	{
		map[warehouse_y][warehouse_x] = 'V'; // если игрок находиться на складе то символ склада меняется с 'W' на 'V'
		warehouse_par = 1; // параметр необходимый для 'выхода' со склада
		post_step = 'W'; // если игрок посетил склад то символ который останется уже не ' ' а 'V'
		rand_gener(); //  если игрок посетил склад то генерируються новые координаты склада
		map[warehouse_y][warehouse_x] = 'W'; // перерисовываем склад
		fuel += full_fuel; // пополняем топливо до полного бака заходя на склад
		warehouse_count += 1; // счеткик кол-ва заходов на склад
		return fuel;
	}
		if (fuel <= 0) // если топливо ровно нулю то игра проиграна
	{
		control = 1; // переменная для выхода из игры
		//game_over(warehouse_count, fuel); //
		return 0;
	}
		return fuel; // если игрок не зашел на склад (функция все равно вызывается каждый ход) возвращаем текущее значение топлива
}
// ВЫВОД КАРТЫ НА ЭКРАН
void display_map() // функция поэлементно выводящая массив на экран
{
	for (int i = 0; i < strings; i++)  // внешний цикл отвечает за строки
	{
		for (int j = 0; j < columns; j++)  // внутрений цикл отвечает за столбцы
		{
			cout << map[i][j]; // в циклах поэлементно выводится массив
		}
		cout << "\n"; // переход на новую строку после каждого "ряда"
	}
}
// СРЕЗ ДНА ПРИ ЗАПОЛНЕНИИ ЛИНИИ
int slice(){
	summ = 0;
	for (int k = 1; k <= (strings-3); k++){	// пройдемся по всем строкам от 1 до strings-3 в поисках полностью заполненой
		for (int i = 2; i <= (columns-2); i++){ // суммируем все элементы в строке кроме стенок итого columns-2
			summ = summ + bottom_y[k][i]; // суммируем все элементы в строке
			}
		//cout  << "k: " << k << "summ: " << summ << "bottom_y[k][2]" << bottom_y[k][2] << "\n";
		slice_count = summ/(columns-3); // узнаем заполнена ли строка длиной (columns-3) где -3 это стенки
		summ = 0;

		if (slice_count == k && slice_count < 88){ // если номер строки заполнен такими же номерами (и это не 99 - 'мусор') то уничтожаем все элементы в строке
			//k = 1;
			square_filling(post_step); // стираем квадрат с экрана чтобы цикл не опустил его вниз во время среза
			for (int k2 = k; k2 > 1; k2--){ // цикл при котором от срезанной строки вверх идет замена строк (создает эффект опускания блоков)
				//cout << "k: " << k << " k2: "<< k2 << " slice_count " << slice_count << " summ " << summ << "\n";
				//_getch();
				for (int j = 2; j <= (columns-2); j++){ 
					map[k2+1][j] = post_step; // стирает последнюю строку на самом дне
					map[k2][j] = map[k2-1][j]; // срезанная строка заполняется верхней в массиве карты
					bottom_y[k2][j] = bottom_y[k2-1][j]; // срезанная строка заполняется верхней в массиве дна
					if (bottom_y[k2][j] < 88){
						bottom_y[k2][j] = bottom_y[k2][j] + 1;
					}
				}
			}
		}
		square_filling(square_symbol); // рисуем квадрат в точке его появления после того как срез окончен
		//cout << "k: " << k << "k2: " << "\n";
	}
	return 0;
}
// ЗАПОЛНЕНИЕ КООРДИНАТ КВАДРАТА РАЗЛИЧНЫМИ СИМВОЛАМИ
char square_filling(char symbol){
	map[square_y0][square_x0] = symbol; // Рисуем нулевой символ квадрата
	map[square_y0][square_x1] = symbol; // Рисуем первый символ квадрата
	map[square_y1][square_x0] = symbol; // Рисуем второй символ квадрата
	map[square_y1][square_x1] = symbol; // Рисуем третий символ квадрата
	return symbol;
}
// ДЕЙСТВИЯ ИГРОКА ПРИ НАЖАТИИ КЛАВИШ
int movement_if(int warehouse_count, int& fuel) // функция для действий игрока
{
	char act; // переменная для считывания ввода пользователя
	int ch; // переменная для хранения приведённого значения переменной act
	if (control == 1) // если игра уже закончена выходим из неё (это необходимо чтобы лишний раз не обращаться к функции _getch())
	{
		ch = 59;	// присваеваем переменной клавишу F1 - выход
	}
	else // если игра еще не закончена обращаемя к функции _getch()
	{
		act = _getch(); // функция ждет нажатия любой клавиши и сохраняет введеный символ как string
		ch = static_cast<int>(act); // переводит формат из символьного в цифровой
	}

		if (ch == -32) // Условие убирает двойной символ для стрелочек
		{}
		else if (ch == 59) // F1 - выход
		{
			return control = 1;
		}
		else if (ch == 60) // F2 - переключения на другое поле
		{
			map[y][x] = post_step; // стираем "старого" персонажа с поля
			if (x < columns/2) // если персонаж находиться на первом поле
			{
				x = columns/2+3; // перемещаем персонажа в начало второго поля
				y = 2;
			}
			else // если персонаж находиться на втором поле
			{
				x = 2; // перемещаем персонажа в начало первого поля
				y = 2;
			}
			map[y][x] = 'T'; //Рисуем игрока
		}
		else if (ch == 61) // F3 - посмотреть результаты
		{
			game_over(warehouse_count, fuel); // функция выводящая результаты игры
		}
		else if (ch == 75)
		{
			// код для передвижения персонажа влево
			//cout << "Шаг влево" << " " << "код: " << act << "(" << static_cast<int>(ch) << ")" << "\n";
			square_filling(post_step); // Предыдущие координаты квадраты заполняются пробелами
			square_x0--;
			square_x1--;
			square_filling(square_symbol); // Рисуем нулевой символ квадрата на новой координате
			//fuel--;
		}
		else if (ch == 77)
		{
			// код для передвижения персонажа вправо
			//cout << "Шаг вправо" << " " << "код: " << act << "(" << static_cast<int>(ch) << ")" << "\n";
			square_filling(post_step); // Предыдущие координаты квадраты заполняются пробелами
			square_x0++;
			square_x1++;
			square_filling(square_symbol); // Рисуем нулевой символ квадрата на новой координате
			//fuel--;
		}
		else if (ch == 72)
		{
			// код для передвижения персонажа вверх
			//cout << "Шаг вверх" << " " << "код: " << act << "(" << static_cast<int>(ch) << ")" << "\n";
			square_filling(post_step); // Предыдущие координаты квадраты заполняются пробелами
			square_y0--;
			square_y1--;
			square_filling(square_symbol); // Рисуем нулевой символ квадрата на новой координате
			//fuel--;
		}
		else if (ch == 80)
		{
			// код для передвижения персонажа вниз
			//cout << "Шаг вниз" << " " << "код: " << act << "(" << static_cast<int>(ch) << ")" << "\n";
			square_filling(post_step); // Предыдущие координаты квадраты заполняются пробелами
			square_y0++;
			square_y1++;
			square_filling(square_symbol); // Рисуем нулевой символ квадрата на новой координате
			//fuel--;
		}
		else // любая другая клавиша выводит сообщение
		{
			cout << "Вы нажали неверную клавишу!" << " " << "код: " << act << "(" << ch << ")" << "\n";
			//_getch();
		}
	return 0;
}
// СКОРОСТЬ ОПУСКАНИЯ КВАДРАТА НА ДНО
int clock_down(){
int clock_dwn = clock() / 10;
	cout << "clock_dwn % 10 - " << clock_dwn % 10 << "\n";
	cout << "clock_dwn " << clock_dwn << "\n";
	while (clock_dwn % 3000 == 0)
	{

	//cout << "clock_dwn2 " << clock_dwn2 << "\n";
		square_filling(post_step); // Предыдущие координаты квадраты заполняются пробелами
		square_y0++;
		square_y1++;
		square_filling(square_symbol); // Рисуем нулевой символ квадрата на новой координате
		//system("cls"); // очистка экрана
		//display_object();
		//display_map();
		clock_dwn = 0;
	}
	return 0;
}
// ВЫВОД РЕЗУЛЬТАТОВ ИГРЫ
void game_over(int warehouse_count, int& fuel)
{
	//if (fuel <= 0) // если топливо закончилось дополнительно выводим текст:
	//{
	//	cout << "\n" << "GAME OVER" << "\n";
	//	cout << "У вас закончилось топливо\n";
	//}
	int f = 0;
	cout << "Нулевая координата квадрата2: " << "x0 = " << square_x0 << " " << "y0 = " << square_y0 << "\n";
	cout << "Первая координата квадрата2: " << "x1 = " << square_x1 << " " << "y0 = " << square_y0 << "\n";
	cout << "Вторая координата квадрата2: " << "x0 = " << square_x0 << " " << "y1 = " << square_y1 << "\n"; 
	cout << "Третья координата квадрата2: " << "x1 = " << square_x1 << " " << "y1 = " << square_y1 << "\n"; 
	cout << "clock()/CLOCKS_PER_SEC " << clock()/CLOCKS_PER_SEC << "\n"; 
	cout << "clock_dwn " << clock() << "\n";
  time_t t = time(NULL);
  tm* aTm = localtime(&t);
  printf("%04d/%02d/%02d %02d:%02d:%02d \n",aTm->tm_year+1900, aTm->tm_mon+1, aTm->tm_mday, aTm->tm_hour, aTm->tm_min, aTm->tm_sec);

		for (int i = 0; i < strings; i++)  // внешний цикл отвечает за строки
	{
		for (int j = 0; j < columns; j++)  // внутрений цикл отвечает за столбцы
		{
			cout << bottom_y[i][j]; // в циклах поэлементно выводится массив
		}
		cout << "\n"; // переход на новую строку после каждого "ряда"
	}
	_getch(); //функция ожидающая нажатия любой клавиши
	_getch(); //функция ожидающая нажатия любой клавиши
}
